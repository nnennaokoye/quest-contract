#![cfg(test)]

use super::*;
use soroban_sdk::{testutils::Address as _, Address, Env, String};

#[test]
fn test_nft_lifecycle() {
    // 1. Setup the Soroban Environment
    let env = Env::default();
    
    // Enable mock auth so require_auth() calls pass automatically during tests
    env.mock_all_auths();

    // 2. Register the AchievementNFT contract and create a client
    // Note: AchievementNFTClient is automatically generated by the #[contract] macro in lib.rs
    let contract_id = env.register_contract(None, AchievementNFT);
    let client = AchievementNFTClient::new(&env, &contract_id);

    // 3. Generate test addresses for different roles
    let admin = Address::generate(&env);
    let user_a = Address::generate(&env);
    let user_b = Address::generate(&env);

    // 4. Initialize the contract state
    client.initialize(&admin);

    // 5. Test Minting Functionality
    let metadata = String::from_str(&env, "First Puzzle Master");
    let puzzle_id = 101;
    
    let token_id = client.mint(&user_a, &puzzle_id, &metadata);
    
    // Assertions for Minting
    assert_eq!(token_id, 1);
    assert_eq!(client.total_supply(), 1);
    assert_eq!(client.owner_of(&token_id), user_a);

    // Verify achievement data storage
    let achievement = client.get_achievement(&token_id).unwrap();
    assert_eq!(achievement.puzzle_id, puzzle_id);
    assert_eq!(achievement.owner, user_a);

    // 6. Test Transfer Functionality (SEP-41 Compliance)
    client.transfer(&user_a, &user_b, &token_id);
    
    // Assertions for Transfer
    assert_eq!(client.owner_of(&token_id), user_b);
    assert_eq!(client.total_supply(), 1); // Supply shouldn't change on transfer

    // 7. Test Burning/Revoking Functionality
    client.burn(&token_id);
    
    // Assertions for Burn
    assert_eq!(client.total_supply(), 0);
    assert!(client.get_achievement(&token_id).is_none());
}

#[test]
#[should_panic(expected = "Already initialized")]
fn test_already_initialized() {
    let env = Env::default();
    let contract_id = env.register_contract(None, AchievementNFT);
    let client = AchievementNFTClient::new(&env, &contract_id);

    let admin = Address::generate(&env);
    client.initialize(&admin);
    
    // This second call should trigger the panic
    client.initialize(&admin);
}

#[test]
#[should_panic(expected = "Token does not exist")]
fn test_transfer_non_existent_token() {
    let env = Env::default();
    env.mock_all_auths();
    
    let contract_id = env.register_contract(None, AchievementNFT);
    let client = AchievementNFTClient::new(&env, &contract_id);

    let admin = Address::generate(&env);
    let user_a = Address::generate(&env);
    let user_b = Address::generate(&env);

    client.initialize(&admin);
    
    // Attempting to transfer token 999 which was never minted
    client.transfer(&user_a, &user_b, &999);
}